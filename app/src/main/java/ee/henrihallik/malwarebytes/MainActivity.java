package ee.henrihallik.malwarebytes;

import android.Manifest;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.os.Bundle;
import android.os.Environment;
import android.text.Editable;
import android.text.TextUtils;
import android.text.TextWatcher;
import android.util.Log;
import android.view.View;
import android.widget.Button;
import android.widget.EditText;
import android.widget.RelativeLayout;
import android.widget.Toast;

import androidx.annotation.NonNull;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.app.ActivityCompat;
import androidx.core.content.ContextCompat;
import androidx.recyclerview.widget.DividerItemDecoration;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;
import androidx.work.OneTimeWorkRequest;
import androidx.work.WorkInfo;
import androidx.work.WorkManager;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.file.Files;
import java.util.ArrayList;

import static ee.henrihallik.malwarebytes.FileDetailsActivity.KEY_FULL_FILE_PATH;

public class MainActivity extends AppCompatActivity implements FileListAdapter.ListItemClickListener, SortingTask.OnPostSortListener {
    private static final String TAG = MainActivity.class.getName();
    private FileListAdapter mAdapter;
    private RelativeLayout mProgressBarHolder;
    private ArrayList<File> mFiles;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button mScanButton = findViewById(R.id.scanButton);
        mScanButton.setOnClickListener(
                view -> scanFileSystem());

        final RecyclerView recyclerView = findViewById(R.id.recyclerview);
        mAdapter = new FileListAdapter(this, this);
        recyclerView.setAdapter(mAdapter);
        recyclerView.setLayoutManager(new LinearLayoutManager(this));
        DividerItemDecoration dividerItemDecoration = new DividerItemDecoration(recyclerView.getContext(),
                DividerItemDecoration.VERTICAL);
        recyclerView.addItemDecoration(dividerItemDecoration);

        mProgressBarHolder = findViewById(R.id.progressBarHolder);

        //https://stackoverflow.com/questions/7117209/how-to-know-key-presses-in-edittext
        EditText editText = findViewById(R.id.editText);
        editText.addTextChangedListener(new TextWatcher() {
            @Override
            public void onTextChanged(CharSequence s, int start, int before, int count) {
                runOnUiThread(() -> {
                    mAdapter.setHighlightText(s.toString());
                    mAdapter.notifyDataSetChanged();
                });
            }
            @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) {}
            @Override public void afterTextChanged(Editable s) {}
        });

        findViewById(R.id.azSortButton).setOnClickListener(view -> {
            showProgress();
            new SortingTask(mFiles,this).execute(SortingTask.MODE.ALPHABETICAL, null, null);
        });

        findViewById(R.id.chronoSortButton).setOnClickListener(view -> {
            showProgress();
            new SortingTask(mFiles, this).execute(SortingTask.MODE.CHRONOLOGICAL, null, null);
        });

        findViewById(R.id.extensionSortButton).setOnClickListener(view -> {
            showProgress();
            new SortingTask(mFiles, this).execute(SortingTask.MODE.BY_EXTENSION, null, null);
        });

        findViewById(R.id.findButton).setOnClickListener(view -> {
            showProgress();
            String search=editText.getText().toString();
            new SortingTask(mFiles, this, search).execute(SortingTask.MODE.FIND_IN_FILENAMES, null, null);
        });

        findViewById(R.id.saveButton).setOnClickListener(view -> {
            //https://stackoverflow.com/questions/9292954/how-to-make-a-copy-of-a-file-in-android
            File src = new File(FileSystemScanWorker.TEMP_RESULTS_FILE_FULL_PATH);
            File dst = new File(Environment.getExternalStorageDirectory()+"/scan_"+System.currentTimeMillis()+".txt");
            try {
                Files.copy(src.toPath(), dst.toPath());
                Toast.makeText(this, "Results saved to: "+dst.getPath(), Toast.LENGTH_SHORT).show();
            } catch (IOException e) {
                e.printStackTrace();
                Toast.makeText(this, "Saving results failed!", Toast.LENGTH_SHORT).show();
            }
        });
    }


    public void scanFileSystem(){

        showProgress();

        final OneTimeWorkRequest workRequest = new OneTimeWorkRequest.Builder(FileSystemScanWorker.class).build();
        WorkManager.getInstance(getApplication()).getWorkInfoByIdLiveData(workRequest.getId())
                .observe(this, workInfo -> {
                    Log.d(TAG, "Workstate=" + workInfo.getState().name() + "\n");
                    if( workInfo.getState()==WorkInfo.State.SUCCEEDED) {
                        updateList();
                    }
                });

        WorkManager.getInstance(getApplication()).enqueue(workRequest);
    }

    private void updateList(){
        InputStream is;
        try {
            is = new FileInputStream(FileSystemScanWorker.TEMP_RESULTS_FILE_FULL_PATH);
            if (is != null) {
                InputStreamReader inputreader = new InputStreamReader(is);
                BufferedReader buffreader = new BufferedReader(inputreader);
                String line;
                mFiles = new ArrayList<>();
                do {
                    line = buffreader.readLine();
                    if(!TextUtils.isEmpty(line)) {
                        File file = new File(line);
                        mFiles.add(file);
                    }
                } while (line != null);
                is.close();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

        mAdapter.setFiles(mFiles);
        hideProgess();
        notifyMatches(mFiles.size());
    }

    @Override
    protected void onResume(){
        super.onResume();
        Log.d(TAG, "isExternalStorageLegacy =  "+ Environment.isExternalStorageLegacy());
        boolean hasPermission =(
                ContextCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE)
                == PackageManager.PERMISSION_GRANTED
                && ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE)
                == PackageManager.PERMISSION_GRANTED);
        if (!hasPermission){
            ActivityCompat.requestPermissions( this,
                    new String[]{Manifest.permission.READ_EXTERNAL_STORAGE, Manifest.permission.WRITE_EXTERNAL_STORAGE}, 1);
        }else {
            if(mFiles==null) scanFileSystem();
        }
    }

    @Override
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults);
        if (requestCode == 1) {
            if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                scanFileSystem();
            }
        }
    }
    private void showProgress(){
        if(mProgressBarHolder!=null) mProgressBarHolder.setVisibility(View.VISIBLE);
    }
    private void hideProgess(){
        if(mProgressBarHolder!=null) mProgressBarHolder.setVisibility(View.GONE);
    }

    private void notifyMatches(int numberOfMatches){
        String msg = "Found "+numberOfMatches+" files";
        Toast.makeText(this, msg, Toast.LENGTH_SHORT).show();
    }

    @Override
    public void onListItemClick(int position) {
        Intent intent = new Intent(this, FileDetailsActivity.class);
        intent.putExtra(KEY_FULL_FILE_PATH, mFiles.get(position).getPath());
        startActivity(intent);
    }

    @Override
    public void onPostExecute(ArrayList<File> files, SortingTask.MODE mode) {
        hideProgess();
        if(mode==SortingTask.MODE.FIND_IN_FILENAMES){
            String msg = "Found "+files.size()+" matches for input string";
            Toast.makeText(this, msg, Toast.LENGTH_LONG).show();
        }else {
            mFiles = files;
            mAdapter.setFiles(mFiles);
        }
    }
}