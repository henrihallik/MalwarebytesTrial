package ee.henrihallik.malwarebytes;

import android.Manifest;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.os.Bundle;
import android.os.Environment;
import android.text.Editable;
import android.text.TextWatcher;
import android.util.Log;
import android.view.View;
import android.widget.Button;
import android.widget.EditText;
import android.widget.RelativeLayout;
import android.widget.Toast;

import androidx.annotation.NonNull;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.app.ActivityCompat;
import androidx.core.content.ContextCompat;
import androidx.recyclerview.widget.DividerItemDecoration;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;
import androidx.work.OneTimeWorkRequest;
import androidx.work.WorkInfo;
import androidx.work.WorkManager;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.file.Files;
import java.util.ArrayList;

import static ee.henrihallik.malwarebytes.FileDetailsActivity.KEY_FULL_FILE_PATH;

public class MainActivity extends AppCompatActivity implements FileListAdapter.ListItemClickListener{
    private static final String TAG = MainActivity.class.getName();
    private Button mScanButton;
    private FileListAdapter mAdapter;
    private RelativeLayout mProgressBarHolder;

   // private FileViewModel mFileViewModel;

    private ArrayList<File> mFiles;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
       // mFileViewModel = new ViewModelProvider(this,
         //       ViewModelProvider.AndroidViewModelFactory.getInstance(getApplication())).get(FileViewModel.class);
        mScanButton = findViewById(R.id.scanButton);
        mScanButton.setOnClickListener(
                view -> scanFileSystem());

        final RecyclerView recyclerView = findViewById(R.id.recyclerview);
        mAdapter = new FileListAdapter(this, this);
        recyclerView.setAdapter(mAdapter);
        recyclerView.setLayoutManager(new LinearLayoutManager(this));
        DividerItemDecoration dividerItemDecoration = new DividerItemDecoration(recyclerView.getContext(),
                DividerItemDecoration.VERTICAL);
        recyclerView.addItemDecoration(dividerItemDecoration);

        mProgressBarHolder = findViewById(R.id.progressBarHolder);

        //https://stackoverflow.com/questions/7117209/how-to-know-key-presses-in-edittext
        EditText editText = findViewById(R.id.editText);
        editText.addTextChangedListener(new TextWatcher() {
            @Override
            public void onTextChanged(CharSequence s, int start, int before, int count) {
                runOnUiThread(() -> {
                    FileListAdapter adapter = (FileListAdapter)recyclerView.getAdapter();
                    RecyclerView.LayoutManager layoutManager = recyclerView.getLayoutManager();
                    adapter.setHighlightText(s.toString());
                    recyclerView.setAdapter(null);
                    recyclerView.setLayoutManager(null);
                    recyclerView.setAdapter(adapter);
                    recyclerView.setLayoutManager(layoutManager);
                    adapter.notifyDataSetChanged();
                });
            }
            @Override
            public void beforeTextChanged(CharSequence s, int start, int count, int after) {}
            @Override
            public void afterTextChanged(Editable s) {}
        });

        findViewById(R.id.azSortButton).setOnClickListener(view -> {
            mFiles.sort((file1, file2) -> file1.getName().compareTo(file2.getName()));
            mAdapter.setFiles(mFiles);
        });

        findViewById(R.id.chronoSortButton).setOnClickListener(view -> {
            mFiles.sort((file1, file2) -> Long.compare(file1.lastModified(), file2.lastModified()));
            mAdapter.setFiles(mFiles);
        });

        findViewById(R.id.extensionSortButton).setOnClickListener(view -> {
            mFiles.sort((file1, file2) -> getExt(file1.getName()).compareTo(getExt(file2.getName())));
            mAdapter.setFiles(mFiles);
        });

        findViewById(R.id.saveButton).setOnClickListener(view -> {
            //https://stackoverflow.com/questions/9292954/how-to-make-a-copy-of-a-file-in-android
            File src = new File(FileSystemScanWorker.TEMP_RESULTS_FILE_FULL_PATH);
            File dst = new File(Environment.getExternalStorageDirectory()+"/scan_"+System.currentTimeMillis()+".txt");
            try {
                Files.copy(src.toPath(), dst.toPath());
            } catch (IOException e) {
                e.printStackTrace();
            }

            /*
            String searchString = editText.getText().toString();
            editText.setText("");
            ArrayList<File> some = App.files.stream().filter(file -> file.getName().contains(searchString))
                    .collect(Collectors.toCollection(ArrayList::new));
            mAdapter.setFiles(some);
            notifyMatches(some.size());
             */
        });
    }

    public String getExt(String fileName){
        int strLength = fileName.lastIndexOf(".");
        if(strLength > 0) return fileName.substring(strLength + 1).toLowerCase();
        return "";
    }

    public void scanFileSystem(){
        showProgress();

        final OneTimeWorkRequest workRequest = new OneTimeWorkRequest.Builder(FileSystemScanWorker.class).build();

        WorkManager.getInstance(getApplication()).getWorkInfoByIdLiveData(workRequest.getId())
                .observe(this, workInfo -> {
                    Log.d(TAG, "Workstate=" + workInfo.getState().name() + "\n");
                    if( workInfo.getState()==WorkInfo.State.SUCCEEDED) {
                        InputStream is = null;
                        try {
                            is = new FileInputStream(FileSystemScanWorker.TEMP_RESULTS_FILE_FULL_PATH);
                            if (is != null) {
                                InputStreamReader inputreader = new InputStreamReader(is);
                                BufferedReader buffreader = new BufferedReader(inputreader);
                                String line;
                                mFiles = new ArrayList<>();
                                do {
                                    line = buffreader.readLine();
                                    File file = new File(line);
                                    mFiles.add(file);
                                } while (line != null);
                                is.close();
                            }
                        } catch (Exception e) {
                            e.printStackTrace();
                        }

                        mAdapter.setFiles(mFiles);
                        hideProgess();
                        notifyMatches(mFiles.size());
                    }
                });

        WorkManager.getInstance(getApplication()).enqueue(workRequest);
    }

    @Override
    protected void onResume(){
        super.onResume();
        Log.d(TAG, "isExternalStorageLegacy =  "+ Environment.isExternalStorageLegacy());
        boolean hasPermission =(
                ContextCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE)
                == PackageManager.PERMISSION_GRANTED
                && ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE)
                == PackageManager.PERMISSION_GRANTED);
        if (!hasPermission){
            ActivityCompat.requestPermissions( this,
                    new String[]{Manifest.permission.READ_EXTERNAL_STORAGE, Manifest.permission.WRITE_EXTERNAL_STORAGE}, 1);
        }else {
            if(mFiles==null) scanFileSystem();
        }
    }

    @Override
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults);
        if (requestCode == 1) {
            if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                scanFileSystem();
            } else {

            }
        }
    }
    private void showProgress(){
        if(mProgressBarHolder!=null) mProgressBarHolder.setVisibility(View.VISIBLE);
    }
    private void hideProgess(){
        if(mProgressBarHolder!=null) mProgressBarHolder.setVisibility(View.GONE);
    }

    private void notifyMatches(int numberOfMatches){
        Toast.makeText(this, "Found "+numberOfMatches+" files", Toast.LENGTH_SHORT).show();
    }

    @Override
    public void onListItemClick(int position) {
        Intent intent = new Intent(this, FileDetailsActivity.class);
        intent.putExtra(KEY_FULL_FILE_PATH, mFiles.get(position).getPath());
        startActivity(intent);
    }
}